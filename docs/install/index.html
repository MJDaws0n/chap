<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Chap Install Guide</title>
	<link rel="stylesheet" href="../css/api.css" />
</head>
<body>
	<header class="topbar">
		<div class="wrap">
			<div class="brand">Chap Install Guide</div>
			<p class="subtitle">Install and production setup for chap-server + chap-node, with reverse proxy (ProxyDNSCache recommended)</p>
		</div>
	</header>

	<div class="layout">
		<aside class="sidebar">
			<h3>Contents</h3>
			<nav class="nav">
				<a href="#install">Installation</a>
				<a href="#prereqs">Prerequisites</a>
				<a href="#reverse-proxy">Reverse Proxy</a>
				<a href="#proxy-cert">ProxyDNSCache Certs</a>
				<a href="#proxy-service">ProxyDNSCache Service</a>
				<a href="#proxy-config">ProxyDNSCache Config</a>
				<a href="#proxy-dns">DNS Records</a>
				<a href="#server">Chap Server</a>
				<a href="#node">Chap Node</a>
				<a href="#update">Update</a>
			</nav>
		</aside>

		<main>
			<section id="install" class="panel intro">
				<div>
					<h2>Installation</h2>
					<p>This guide covers how to get chap-server and chap-node running with modern styles. ProxyDNSCache is strongly recommended for reverse proxy and wildcard subdomain TLS. You'll need Docker + Compose, open ports, and root/sudo for certs.</p>
				</div>
			</section>

			<section id="prereqs" class="section">
				<h3>Prerequisites</h3>
				<div class="grid cards">
					<div class="card">
						<h3>Docker + Compose</h3>
						<p>Docker and Docker Compose (API ≥ 1.53) on server and nodes.</p>
					</div>
					<div class="card">
						<h3>No auto updates</h3>
						<p>No version control: check the repo for updates manually.</p>
					</div>
					<div class="card">
						<h3>SSL &amp; Proxy</h3>
						<p>If using SSL/domain, a reverse proxy is required. ProxyDNSCache is built for Chap.</p>
					</div>
					<div class="card">
						<h3>Privileges</h3>
						<p>Root/sudo access ideal (tested with it).</p>
					</div>
					<div class="card">
						<h3>Ports</h3>
						<p>Server: two open ports. Node: one open port.</p>
					</div>
				</div>
			</section>

			<section id="reverse-proxy" class="section">
				<h3>Reverse Proxy (ProxyDNSCache recommended)</h3>
				<p>
					Best to set up ProxyDNSCache first, on both server and nodes.<br>
					Needs ports <strong>80</strong>, <strong>443</strong>, and <strong>441</strong> open.<br>
					If you're running nginx/apache, move those off 80/443 and reverse proxy through ProxyDNSCache.
				</p>
				<div class="callout">
					If your domain's on Cloudflare, the guide uses its API to automate wildcard TLS.
				</div>
			</section>

			<section id="proxy-cert" class="section">
				<h3>ProxyDNSCache: Wildcard Cert with Certbot + Cloudflare</h3>
				<p>
					Wildcard allows you to add subdomains just by DNS.<br>
					Follow <strong>on both server and nodes</strong>. Needs sudo.
				</p>
				<div class="group">
					<h4>Remove old certbot</h4>
					<pre class="code">
sudo apt-get remove certbot
sudo apt autoremove
					</pre>

					<h4>Install dependencies</h4>
					<pre class="code">
sudo apt update
sudo apt install python3 python3-dev python3-venv libaugeas-dev gcc
					</pre>

					<h4>Create venv &amp; install pip/certbot</h4>
					<pre class="code">
sudo python3 -m venv /opt/certbot/
sudo /opt/certbot/bin/pip install --upgrade pip
sudo /opt/certbot/bin/pip install certbot
sudo ln -s /opt/certbot/bin/certbot /usr/local/bin/certbot
					</pre>

					<h4>Auto renew</h4>
					<pre class="code">
echo "0 0,12 * * * root /opt/certbot/bin/python -c 'import random; import time; time.sleep(random.random() * 3600)' && sudo certbot renew -q" | sudo tee -a /etc/crontab > /dev/null
					</pre>

					<h4>Cloudflare Plugin</h4>
					<pre class="code">
source /opt/certbot/bin/activate
pip install certbot-dns-cloudflare
deactivate
					</pre>
					<p>
						Create <code>cloudflare.ini</code>:<br>
						<pre class="code">
dns_cloudflare_api_token = KEY HERE
						</pre>
						<small>Set permissions (& path):</small>
						<pre class="code">
sudo chmod 600 /path/to/cloudflare.ini
						</pre>
					</p>

					<h4>Generate wildcard cert</h4>
					<pre class="code">
sudo certbot certonly --dns-cloudflare --dns-cloudflare-credentials /path/to/cloudflare.ini --preferred-challenges dns -d domain.com -d '*.domain.com'
					</pre>
				</div>
			</section>

			<section id="proxy-service" class="section">
				<h3>ProxyDNSCache: systemd Service</h3>
				<div class="group">
					<h4>Create service file</h4>
					<pre class="code">
sudo nano /etc/systemd/system/ProxyDNSCache.service
					</pre>
					<p>Contents (fix <code>ExecStart</code>/paths):</p>
					<pre class="code">
[Unit]
Description=ProxyDNSCache
After=network.target

[Service]
WorkingDirectory=/home/ProxyDNSCache
ExecStart=/home/ProxyDNSCache/ProxyDNSCache-linux
Restart=always
Environment=NODE_ENV=production

[Install]
WantedBy=multi-user.target
					</pre>
					<p>
						Non-root: allow privileged port bind
						<pre class="code">
sudo setcap 'cap_net_bind_service=+ep' /home/ProxyDNSCache/ProxyDNSCache-linux
						</pre>
					</p>

					<h4>Enable / Start</h4>
					<pre class="code">
sudo systemctl daemon-reload
sudo systemctl enable --now ProxyDNSCache
sudo journalctl -u ProxyDNSCache -f
					</pre>
				</div>
			</section>

			<section id="proxy-config" class="section">
				<h3>ProxyDNSCache: config.yml</h3>
				<pre class="code">
certs:
    - "example.com":
            - cert: "/etc/letsencrypt/live/example.com/fullchain.pem"
                key: "/etc/letsencrypt/live/example.com/privkey.pem"
    - "*.example.com":
            - cert: "/etc/letsencrypt/live/example.com/fullchain.pem"
                key: "/etc/letsencrypt/live/example.com/privkey.pem"
				</pre>
			</section>

			<section id="proxy-dns" class="section">
				<h3>DNS Records (ProxyDNSCache Routing)</h3>
				<div class="grid cards">
					<div class="card">
						<h3>A Records</h3>
						<p>For main panel, websocket, and each node.</p>
					</div>
					<div class="card">
						<h3>SRV Records</h3>
						<p>Each points <code>_pdcache._tcp.[domain]</code> to the right target + port.</p>
					</div>
				</div>
				<pre class="code">
# Main panel domain
_pdcache._tcp.chap.example.com SRV 0 0 8080 localhost.

# Server websocket
_pdcache._tcp.chap-ws.example.com SRV 0 0 8081 localhost.

# Each node
_pdcache._tcp.chap-node-1.example.com SRV 0 0 6002 localhost.
				</pre>
			</section>

			<section id="server" class="section">
				<h3>Installing Chap Server</h3>
				<div class="group">
					<h4>Clone & setup</h4>
					<pre class="code">
cd ~/
git clone https://github.com/MJDaws0n/chap.git
mv chap chap-server
cd chap-server
cp .env.example .env
nano .env
					</pre>
					<div class="grid cards">
						<div class="card"><h3>APP_URL</h3><p>Reverse proxy URL</p></div>
						<div class="card"><h3>APP_SECRET</h3><p>Secure random string (don't share)</p></div>
						<div class="card"><h3>APP_PORT</h3><p>Main panel port (matches proxy)</p></div>
						<div class="card"><h3>WS_PORT</h3><p>Websocket port (matches proxy)</p></div>
						<div class="card"><h3>DB_PASSWORD</h3><p>Secure random</p></div>
						<div class="card"><h3>DB_ROOT_PASSWORD</h3><p>Secure random</p></div>
						<div class="card"><h3>CAPTCHA_PROVIDER</h3><p>none/recaptcha/autogate</p></div>
					</div>
					<h4>Build &amp; Start</h4>
					<pre class="code">
docker compose -f docker-compose.server.yml up --build
docker compose -f docker-compose.server.yml up -d
					</pre>
					<div class="callout">
						Default: <code>admin@chap.dev</code> / <code>password</code> <br>
						Change these right after logging in.
					</div>
				</div>
			</section>

			<section id="node" class="section">
				<h3>Installing Chap Node</h3>
				<div class="group">
					<h4>Check Docker version</h4>
					<pre class="code">
docker version
					</pre>
					<p>
						Must be ≥ 1.53 (see "API version" in Docker Engine section).
					</p>
					<h4>Add node in panel</h4>
					<ol>
						<li>Go to Nodes &gt; Add Node</li>
						<li>Set port range</li>
						<li>Note <code>NODE_ID</code> and <code>NODE_TOKEN</code></li>
					</ol>
					<h4>Clone & setup node</h4>
					<pre class="code">
cd ~/
git clone https://github.com/MJDaws0n/chap.git
mv chap chap-node
cd chap-node
cp node/.env.example .env
nano .env
					</pre>
					<div class="grid cards">
						<div class="card"><h3>NODE_ID</h3><p>From dashboard</p></div>
						<div class="card"><h3>NODE_TOKEN</h3><p>From dashboard</p></div>
						<div class="card"><h3>CHAP_SERVER_URL</h3><p>Websocket SRV domain (e.g. chap-ws.example.com)</p></div>
						<div class="card"><h3>BROWSER_WS_PORT</h3><p>Proxy-set logs socket port</p></div>
					</div>
					<h4>Build &amp; Start</h4>
					<pre class="code">
docker compose -f docker-compose.node.yml up --build
docker compose -f docker-compose.node.yml up -d
					</pre>
					<div class="callout">
						Node should show online in Chap panel.
					</div>
				</div>
			</section>

			<section id="update" class="section">
				<h3>Updating</h3>
				<div class="grid cards">
					<div class="card">
						<h3>Node update</h3>
						<pre class="code">
git clone https://github.com/MJDaws0n/chap.git ~/temp && rsync -a --exclude='.env' ~/temp/ ~/chap-node/ && rm -rf ~/temp

cd ~/chap-node/
docker compose -f docker-compose.node.yml up --build
# Then:
docker compose -f docker-compose.node.yml up -d
						</pre>
					</div>
					<div class="card">
						<h3>Server update</h3>
						<pre class="code">
git clone https://github.com/MJDaws0n/chap.git ~/temp && rsync -a --exclude='.env' ~/temp/ ~/chap-server/ && rm -rf ~/temp

cd ~/chap-server/
docker compose -f docker-compose.server.yml up --build
# Then:
docker compose -f docker-compose.server.yml up -d
						</pre>
					</div>
				</div>
			</section>
		</main>
	</div>
	<div class="footer wrap">© MJDawson - Chap</div>
	<div id="toast" class="toast" role="status" aria-live="polite"></div>
	<script>
		let toastTimer;
		const toast = document.getElementById('toast');

		function showToast(message) {
			toast.textContent = message;
			toast.classList.add('show');
			clearTimeout(toastTimer);
			toastTimer = setTimeout(() => toast.classList.remove('show'), 1200);
		}

		async function copyText(text) {
			try {
				await navigator.clipboard.writeText(text);
				showToast('Copied to clipboard');
			} catch (err) {
				const textarea = document.createElement('textarea');
				textarea.value = text;
				document.body.appendChild(textarea);
				textarea.select();
				document.execCommand('copy');
				document.body.removeChild(textarea);
				showToast('Copied to clipboard');
			}
		}

		document.querySelectorAll('.code').forEach((el) => {
			el.classList.add('copyable');
			el.setAttribute('title', 'Click to copy');
			el.addEventListener('click', () => {
				copyText(el.textContent.trim());
			});
		});
	</script>
</body>
</html>